# -*- coding: utf-8 -*-
"""Route-Optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/165hV3ecBCqL8D4fh1Rr-4_XDe-F6efsI
"""

!pip install deap

"""Installing DEAP

DEAP - Distributed Evolutionary Algorithms in Python

DEAP is a Python framework for implementing distributed evolutionary algorithms. It facilitates the creation and optimization of custom algorithms for various optimization problems.
"""

import random
import numpy as np
import matplotlib.pyplot as plt
from deap import base
from deap import creator
from deap import tools
from deap import algorithms

"""Importing necessary modules and packages for evolutionary computation using DEAP:-


*   random for random number generation
*   numpy for numerical operations
*   matplotlib for plotting
*   DEAP's base, creator, and tools modules for defining evolutionary algorithms and manipulating individuals and populations.








"""

num_locations = 50;
location_points = [(random.randint(0, 100), random.randint(0, 100)) for _ in range(num_locations)]
depot = (50 ,50)
num_vehicles = 1

"""defining variables


*   num_locations = number of locations that needs to be visited
*   location_points = co-ordinates of the locations
*   depot = co-ordinates of the depot i.e, starting points of all vehicles
*   num_vehicles = number of vehicles we have


"""

creator.create("FitnessMin" , base.Fitness , weights=(-1.0 ,-1.0))
creator.create("Individual" , list , fitness=creator.FitnessMin)

"""Setting up for genetic algorithm -



*   Defining a Fitness Function that needs to minimized given the objectives which are total distance travelled and balance penalty


*   Defining Individual Structure , here that are the lists with fitness attributes



"""

toolbox = base.Toolbox()
toolbox.register("indices" , random.sample , range(num_locations) , num_locations)
toolbox.register("individual" , tools.initIterate , creator.Individual , toolbox.indices)
toolbox.register("population" , tools.initRepeat , list , toolbox.individual)

"""setting up a toolbox with functions for generating individuals and populations for an evolutionary algorithm."""

def evaluate(individual):
    total_dist = 0
    distances = []

    for i in range(num_vehicles):
        route = [depot] + [location_points[individual[j]] for j in range(i , len(individual) , num_vehicles)] + [depot]

        vehicle_dist = sum(np.linalg.norm(np.array(route[k+1]) - np.array(route[k])) for k in range(len(route) - 1))
        total_dist += vehicle_dist

        distances.append(vehicle_dist)
    balance_penalty = np.std(distances)
    return total_dist , balance_penalty

"""Evaluating the fitness of an individual by calculating the total distance traveled by all vehicles and penalizing imbalance in the distribution of distances among vehicles."""

toolbox.register("evaluate" , evaluate)
toolbox.register("mate" , tools.cxPartialyMatched)
toolbox.register("mutate" , tools.mutShuffleIndexes , indpb=0.075)
toolbox.register("select" , tools.selTournament , tournsize=3)

""" Registering the necessary evolutionary operators (evaluation, mating, mutation, and selection) in the toolbox, enabling their use during the evolutionary process.






"""

def plot_routes(individual):
    plt.figure(figsize=(10, 6))

    for (x, y) in location_points:
        plt.plot(x, y, 'bo', markersize=8)

    plt.plot(depot[0], depot[1], 'rs', markersize=8, label='Depot')
    plt.text(depot[0], depot[1], 'Depot', verticalalignment='bottom', horizontalalignment='right', color='red', fontsize=10)

    for i in range(num_vehicles):
        route = [depot] + [location_points[individual[j]] for j in range(i, len(individual), num_vehicles)] + [depot]
        plt.plot(*zip(*route), '-', label=f'Vehicle {i+1}')

        for k, (x, y) in enumerate(route):
            plt.text(x, y, f'{k}', verticalalignment='bottom', horizontalalignment='right', color='black', fontsize=8)

    plt.legend()
    plt.grid(True)
    plt.xlabel('X-Coordinate')
    plt.ylabel('Y-Coordinate')
    plt.title('Vehicle Routes Visualization')
    plt.show()

"""Function to create a plot to visualize the locations, depot, and routes of vehicles based on the given individual solution."""

def main():
    random.seed(42)
    pop = toolbox.population(n=300)
    hof = tools.HallOfFame(1)

    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg" , np.mean)
    stats.register("min" , np.min)

    algorithms.eaSimple(pop , toolbox , 0.7 , 0.2 , 300 , stats = stats , halloffame = hof)

    plot_routes(hof[0])
    return pop , stats , hof

if __name__ == "__main__":
    main()